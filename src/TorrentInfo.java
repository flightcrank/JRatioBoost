
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayDeque;
import java.util.ArrayList;

class TorrentInfo {

	String announce;		//tracker announce url
	String creationDate;		//torrent creation date
	String createdBy;		//author for torrent file
	String comment;			//torrent comments
	String size;			//download size of torrent	
	String name;			//filename (singlefile) or dirname (multifile)	
	String encoding;	
	ArrayList<String> announceList;	//list of announce urls
	byte[] infoHash;		//20 byte torrent SHA1 info hash
	byte[] peerId;			//20 byte torrent SHA1 info hash
	public static final int INFO_HASH = 0;
	public static final int PEER_ID = 1;

	public TorrentInfo(FileInputStream file) throws IOException, Exception {
		
		Blex lexTree = new Blex(file);

		if (lexTree.valid) {
			
			announceList = new ArrayList<String>();
			infoHash = new byte[20]; 
			peerId = new byte[20]; 
			
			setInfo(lexTree.tokenList);
			computeInfoHash(lexTree.tokenList, file);
			computePeerId("TR4050");

		} else {
			
			throw new Exception("File did not pass bencoded validation test");
		}
	}
	
	public String toString() {
		
		return String.format("TorrentInfo: [%s, %s, %s, %s]", announce, this.hexString(infoHash), this.hexString(peerId), this.hexStringUrlEnc(1));
	}

	//calculate the client peer id
	public void computePeerId(String client) {
		
		byte[] b = client.getBytes();
		
		for (int i = 0; i < peerId.length; i++) {
			
			peerId[i] = (byte) (Math.random() * 256.0);
		}

		peerId[0] = (byte) '-';
		peerId[1] = b[0];
		peerId[2] = b[1];
		peerId[3] = b[2];
		peerId[4] = b[3];
		peerId[5] = b[4];
		peerId[6] = b[5];
		peerId[7] = (byte) '-';
	}

	//covert info hash or peer id to a hexadecimal string
	public String hexString(byte[] a) {
		
		StringBuilder sb = new StringBuilder(a.length * 2);
		
		for(byte b : a) {
			
			sb.append(String.format("%02x", b));
		}
		
		return sb.toString();
	}
	
	//urlencode info hash or peerid hex string
	public String hexStringUrlEnc(int i) {
		
		byte[] hString;

		if (i == INFO_HASH) {
		
			hString = infoHash;
		
		} else {
			
			hString = peerId;
		}

		StringBuilder sb = new StringBuilder();

		for (byte b : hString) {

			if (b >= (int) '0' && b <= (int) '9') {
				
				sb.append((char) b);
			
			} else if (b >= (int) 'a' && b <= (int) 'z') {
			
				sb.append((char) b);
			
			} else if (b >= (int) 'A' && b <= (int) 'Z') {
				
				sb.append((char) b);
			
			} else if (b == (int) '.' || b == (int) '-' || b == (int) '_' || b == (int) '~') {
			
				sb.append((char) b);
			
			} else {
				
				sb.append(String.format("%%%02x", b));
			}
		}
			
		return sb.toString();
	}
	
	//populate instance variables with data from the tokenList generated by the Blex object
	private void setInfo(ArrayList<TokenElement> tokenArray) {
		
		long size = 0;

		for(int i = 0; i < tokenArray.size(); i++) {
			
			String str = tokenArray.get(i).getValueString();
			
			if (str != null && str.equals("announce")) {
				
				i++;
				this.announce = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("created by")) {
				
				i++;
				this.createdBy = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("creation date")) {
				
				i++;
				this.creationDate = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("comment")) {
				
				i++;
				this.comment = tokenArray.get(i).getValueString();
			
			} else if (str != null && str.equals("encoding")) {
				
				i++;
				this.encoding = tokenArray.get(i).getValueString();

			} else if (str != null && str.equals("name")) {
				
				i++;
				this.name = tokenArray.get(i).getValueString();

			} else if (str != null && str.equals("length")) {
				
				i++;
				String num = tokenArray.get(i).getValueString();
				size += Long.parseLong(num);

			} else if (str != null && str.equals("announce-list")) {
				
				i++;
				ArrayDeque<TokenElement> announceStack = new ArrayDeque<TokenElement>();		
				announceStack.push(tokenArray.get(i));
				
				//check if there is a list of LIST token on a stack
				while (!announceStack.isEmpty()) {
					
					i++;

					if (tokenArray.get(i).type == TokenElement.Token.END) {
						
						announceStack.pop();

					} else if (tokenArray.get(i).type == TokenElement.Token.LIST) {
						
						announceStack.push(tokenArray.get(i));

					} else if (tokenArray.get(i).type == TokenElement.Token.BYTESTRING) {
						
						this.announceList.add(tokenArray.get(i).getValueString());
					}
				}
			}
			
			this.size = String.format("%d", size);
		}
	}
	
	//calculate the infoHash
	private void computeInfoHash(ArrayList<TokenElement> tokenList, FileInputStream file) throws IOException{
		
		TokenElement[] tokenArray = new TokenElement[tokenList.size()];
		long startOffset = 0;
		long endOffset = 0;

		tokenArray = tokenList.toArray(tokenArray);
		
		for (int i = 0; i < tokenArray.length; i++) {
			
			String value = tokenArray[i].getValueString();
			
			//search for the info token
			if (value != null && value.equals("info")) {
				
				TokenElement infoDictionary = tokenArray[i + 1];
				TokenElement endToken = tokenArray[infoDictionary.endIndex];
				startOffset = infoDictionary.position - 1;//the read() function will consume the next by so set it 1 position back
				endOffset = endToken.position;
			}
		}
	
		long len = endOffset - startOffset;
		byte[] hashData = new byte[(int)len];
		FileChannel fChan = file.getChannel(); //object to obtain offset current position within the file

		fChan.position(startOffset);
		file.read(hashData);

		try {

			MessageDigest md = MessageDigest.getInstance("SHA-1");
			this.infoHash = md.digest(hashData);

		} catch (NoSuchAlgorithmException e) {

			System.out.println("error:" + e);
		}
	}
}
